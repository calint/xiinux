[ ] clang-tidy
[ ] map doc widget to path '/'
[ ] consider uniform initialization using {...} instead of =
[ ] examine why size of executable compiled by g++ grew from 51K to 61K
    when "template <unsigned M> inline strb &p(const strb<M> &sb)"
    was added to 'strb' and several instances with different sizes
    were created with 'strb' template
[ ] decode query string on demand
[ ] uploaded file names are urlencoded
[ ] sock: consolidate recv(...) in content and buf
[ ] sock: session id from cookie accessible in requests for file and upload
[ ] uploaded file to session directory
[ ] better handling of "accept: Too many open files"
[ ] server: sockopt TCP_FASTOPEN
[ ] review throws messages
[ ] review perror(...) messages
[ ] review args
[ ] xprinter for sockets with buffered sends
[ ] MIME type for ".js" files (warning in Firefox when absent)
[ ] multi-threading clients, chunky pause and resume when write would block
[ ] multi-threading file downloads
    (for nginx performance on multiple worker threads configuration)
[ ] hierarchial widgets
[ ] generate web/web.hpp
--------------------------------------------------------------------------------..
[x] consider "auto f() -> void" type of function declaration
[x] examine why using lut<...>, std::put_time(...) and std::cout increases the
    size of binary so much (~75K -> ~275K)
    => -g was on now ~75K -> ~130K
    => -Os enabled now ~76K
[x] ? lut<std::string_view>
    => deleted
[x] consider going full C++ using std::string, std::string_view and std::unordered_map<...>
    instead of lut<...>
    => ok
[x] using map_headers = std::unordered_map<std::string_view, std::string_view>;
[x] using map_session = std::unordered_map<std::string, std::string>;
[x] using map_widgets = std::unordered_map<std::string, std::unique_ptr<widget>>;
[x] using map_sessions = std::unordered_map<std::string, std::unique_ptr<session>>;
[x] using map_path_to_widget_factory = unordered_map<std::string key, ...>;
[x] sock: when sendfile returns 0 the file size has changed to less than current offset
    => throws
[x] lut: when to delete or delete[] key and data
[x] lut: overwrite does not delete old content
[x] ^C after running:
        curl -sH"Cookie: i=20230926--2020-abcdef" http://localhost:8088/qa/counter?a=1+2 > /dev/null
    generates:
        munmap_chunk(): invalid pointer
        Aborted (core dumped)
    => in web::counter.to(...) r.get_session()->put("x", "abc");
        then lut.delete_content(...) tries to delete const char* 
[x] qa: gnuplot
[x] access path, query, headers, session from widget
    -> access through 'reply'
[x] ? close all sockets in epoll when server::stop to release the port
    -> sockopt SO_REUSEADDR, SO_REUSEPORT set to 1
[x] server: retrieve client ip
[x] server: use accept4 when connecting client
[x] examine why "qa/far_side_dog_ok.jpg" performance lower than nginx when more than 1 client
    -> running nginx on 1 worker thread (config "worker_processes 1;") performs similar (lower)
[x] lut.hash(...) based on pointer address of key
    -> does not work because address might change although key is same
[x] chunky: consolidate flush() and send_chunk()
[x] chunky: when sending string larger than buffer do io_send, skipping copy to buffer
[x] epoll: register and handle client closes connection
[x] qa::page sending an empty string from the browser
[x] widget map to path using function pointers
[-] lut: return std::optional<const T&>
    -> effort failed in complexity
[x] examine if a const ref can be returned from lut to avoid copies of std::function
    -> done and implemented. unclear whether comparing a string twice is cheaper
       than copy a std::function
[x] sock: bind widget factories to paths
[x] review doc. rename to cached
[x] review reply
[x] examine if splicing can occur when doing:
    std::unique_ptr<chunky> y(/*take*/ r.reply_chunky("text/plain;charset=utf-8"));
    xprinter &x = *y;
    -> xprinter &x = *static_cast<xprinter *>(y.get()); is same but if known for supported
       that y is a xprinter then ok
[x] use c++ thread instead of pthread
[x] consolidate sock.io_send, chunky.io_send and reply.send with a helper function
[-] reply.http buffer_send=false
    -> reply.http needs to know the size of the content
[x] reply.http content_type
[x] review strb
[x] review chunky
[x] reduce packets count when sending files
    -> send MSG_NOSIGNAL | MSG_MORE
[x] chunky: sends too many small packets. sudo tcpdump -A -i lo -n port 8088
    -> send MSG_NOSIGNAL | MSG_MORE
[x] review messy args.hpp
    -> looks messy but it is simple
[x] qa: performance comparisons
[x] sock: move bulk of code to do_after_header()
[x] sock: upload overwrites buf
[x] review the messy ssize_t size_t ops in chunky.hpp
[x] format code with standard formatter
[x] change 'int n{1}' -> 'int n = 1'
[-] option for apache-bench compatibility
    -> use other benchmarking tool 'hey'
[x] append '_' to class members
[x] examine whether functions such as 'unsafe_*' get inlined although -Os
    -> using flag -Winline shows that 'unsafe_' not found. non-inlined functions seems ok.
[x] lut: delete without recursion
[x] qa: abuse
[x] change malloc to new where possible
[x] bug: sock::buf gets overwritten when content is sent thrashing the pointers
[-] ? chained requests: path, query string as std::string
    -> not supported
[x] sock: receive content -> use different buffer than the buffer used by request
[x] support for telnet with partial reads of the request
    -> chained request no longer supported
[-] if request line and headers must be read in one read then parsing that part
    of the request can be done in a simpler way
    -> multiple reads ber request
[x] valgrind
[x] abuse errors: request line length, header count, header name length, etc
    -> if total size of request (not including content) is larger than the buffer
       then exception
